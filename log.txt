<2022-04-12>
: Model의 date 형식과 받은 csv파일의 date형식이 달라서 차트가 그려지지 않는 issue 발생

	(2022-04-13 해결)
	정확히 오류가 생긴 구간을 찾지 못하고 있었음.
	장고 shell에서 model의 date값을 출력 해보던 중, 문제 발견.
	실제 date값은 2014-08-04 00:01 이런 식인데,
	date 값이 2014-08-04 00:01:00+00:00 이런 식으로 출력되고 있었음.
	그래서 type이 안맞아서 계속 에러가 나고 있었음.
	기존 utc로 변환하던 방식은
	{
	...
	time_tuple = strptime(str(chart_data.date), '%Y-%m-%d %H:%M') -> format에러 발생!
	utc_now = mktime(time_tuple) * 1000
	...
	}
	model의 date를 추출하여 문자열로 변환 후,
	format을 지정하여 다시 utc로 바꾸는 방식이었음 인터넷을 참고했는데, 상당히 이상한 방식임
	따라서 model의 date를 DateTimeField가 아닌 CharField로 바꾸고 코드를 다음과 같이 수정함.
	{
	...
	time_tuple = strptime(chart_data.date, '%Y-%m-%d %H:%M')
	...
	}

<2022-04-13>
: 데이터가 너무 방대하여 chart를 그려주는 데 너무 오랜 시간이 소요되는 issue 발생

	(2022-04-14 해결)
	기존 csv 데이터는 1분 단위로 내부/외부 온도, 내부 습도, CO2, 자외선을 측정하여 기록한 데이터였음.
	따라서 하루에만 60*24 = 1,440개의 데이터가 존재함.
	해당 데이터는 2014년 8월 한 달간의 데이터였는데, 총 43,000개 가량의 데이터가 존재.
	따라서 차트를 load하는 데 너무나 많은 시간이 소요 됨.
	온도, 습도, CO2, 자외선 등은 단기간 변동량이 크지 않은 데이터임을 고려하여,
	기존 1분 단위 데이터를 5분 단위로 묶어주는 작업을 시행함(데이터는 평균치로 대치)
	-> 각각 컬럼을 5*df.date[i]//5 -> group_by(date).mean()를 통해 그룹화
	하여, 기존 43,000개 가량의 데이터를 8,000개까지 압축하는 데 성공함.
	차트 로딩 시간도 획기적으로 줄일 수 있었음.